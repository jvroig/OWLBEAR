<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OWLBEAR - Enterprise Multi-Agent Demo</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    <style>
        /* Dark mode styles */
        body {
            background-color: #121212;
            color: #e0e0e0;
        }
        
        .panel {
            background-color: #1e1e1e;
            border: 1px solid #333;
        }
        
        .header {
            background-color: #2d2d2d;
            border-bottom: 1px solid #444;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Fixed panel heights */
        .fixed-height {
            max-height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .trace-panel {
            flex: 3;
            min-height: 0;
            max-height: calc(60vh - 5rem); /* 60% of viewport height minus some space for header/footer */
        }
        
        .controls-panel {
            flex: 2;
            min-height: 0;
            overflow-y: auto;
        }
        
        .trace-content {
            overflow-y: auto;
            max-height: 90%;
        }
        
        /* Ansi color codes for log formatting */
        .ansi-black { color: #4e4e4e; }
        .ansi-red { color: #ff6b68; }
        .ansi-green { color: #a8ff60; }
        .ansi-yellow { color: #ffffa6; }
        .ansi-blue { color: #96cbfe; }
        .ansi-magenta { color: #ff73fd; }
        .ansi-cyan { color: #a0d0d0; }
        .ansi-white { color: #f1f1f1; }
        
        /* Animation for "thinking" indicators */
        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }

        .pulse {
            animation: pulse 1.5s infinite ease-in-out;
        }
        
        /* ACTION box styles */
        .viz-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .experts-container {
            flex: 3;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 16px;
            padding: 16px;
            overflow: auto;
        }
        
        .action-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            padding: 0 16px 16px 16px;
        }
        
        .action-box {
            background-color: #2d3748;
            border-radius: 8px;
            padding: 16px;
            width: 80%;
            max-width: 800px;
            text-align: center;
            border: 2px solid #4a5568;
        }
        
        .action-title {
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 8px;
            color: #a0aec0;
        }
        
        .action-content {
            font-size: 1.25rem;
            font-weight: bold;
        }
        
        /* Tools box styles */
        .tools-container {
            flex: 0.5;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 16px 16px 16px;
            margin-top: 10px;
        }
        
        .tools-box {
            background-color: #2d3748;
            border-radius: 8px;
            padding: 12px;
            width: 80%;
            max-width: 800px;
            text-align: center;
            border: 2px solid #4a5568;
        }
        
        .tools-title {
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 8px;
            color: #a0aec0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tools-title i {
            margin-right: 6px;
        }
        
        .tools-content {
            font-size: 1rem;
            color: #e2e8f0;
        }
        
        .tool-item {
            display: inline-flex;
            align-items: center;
            background-color: #4a5568;
            border-radius: 4px;
            padding: 2px 8px;
            margin: 2px;
            white-space: nowrap;
        }
        
        .tool-item i {
            margin-right: 4px;
        }
    </style>
</head>
<body class="h-screen flex flex-col">
    <!-- Banner/Header -->
    <header class="header p-3 flex items-center justify-center">
        <img height="20px" src="/logo"> &nbsp;&nbsp;
        <h1 class="text-xl font-bold">OWLBEAR - Orchestrated Workflow Logic with Bespoke Experts for Agentic Routines</h1>
    </header>
    
    <!-- Main container -->
    <main class="flex-grow flex p-2 gap-2 overflow-hidden">
        <!-- Left column (stacked panels) -->
        <div class="w-1/2 flex flex-col gap-2 fixed-height">
            <!-- Trace History Panel -->
            <div class="panel rounded-md p-3 trace-panel">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="font-bold">Execution Trace</h2>
                    <button id="clearTraceBtn" class="bg-gray-700 hover:bg-gray-600 text-white px-2 py-1 rounded text-sm">
                        Clear Trace History
                    </button>
                </div>
                <div id="traceLog" class="trace-content font-mono text-sm bg-black p-2 rounded h-full">
                    <!-- Trace logs will be displayed here -->
                    <div class="text-gray-500 italic">No workflow execution traces yet.</div>
                </div>
            </div>
            
            <!-- Workflow Controls Panel -->
            <div class="panel rounded-md p-3 controls-panel">
                <h2 class="font-bold mb-2">Workflow Controls</h2>
                <div class="flex-grow flex flex-col overflow-y-auto">
                    <div class="mb-3">
                        <label for="workflowSelect" class="block mb-1">Select Workflow:</label>
                        <select id="workflowSelect" class="w-full bg-gray-800 text-white p-2 rounded border border-gray-700">
                            <option value="">-- Select a workflow --</option>
                            <!-- Workflows will be populated here -->
                        </select>
                    </div>
                    
                    <div id="stringsContainer" class="mb-3 hidden">
                        <label for="stringsSelect" class="block mb-1">Select Strings File:</label>
                        <select id="stringsSelect" class="w-full bg-gray-800 text-white p-2 rounded border border-gray-700">
                            <option value="">-- Use strings from workflow --</option>
                            <!-- String files will be populated here -->
                        </select>
                        <div class="text-xs text-gray-400 mt-1">
                            String files provide template values used in the workflow.
                        </div>
                    </div>
                    
                    <div id="parametersContainer" class="mb-3 hidden">
                        <h3 class="font-bold mb-1">Parameters:</h3>
                        <div id="parametersFields" class="space-y-2">
                            <!-- Parameter fields will be generated here -->
                        </div>
                    </div>
                    
                    <div class="mt-auto flex gap-2">
                        <button id="executeBtn" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded font-bold disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Execute Workflow
                        </button>
                        <button id="cancelBtn" class="bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded font-bold hidden">
                            Cancel Execution
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Right column (visualization panel) -->
        <div class="w-1/2 overflow-hidden">
            <div class="panel rounded-md p-3 h-full flex flex-col overflow-hidden">
                <h2 class="font-bold mb-2">Agent Visualization</h2>
                <div id="visualization" class="flex-grow bg-gray-900 rounded flex items-center justify-center overflow-auto">
                    <!-- Visualization will be rendered here -->
                    <div class="text-gray-500 italic">Select a workflow to visualize the experts and their interactions.</div>
                </div>
            </div>
        </div>
    </main>
    
    <!-- Footer -->
    <footer class="header p-2 text-center text-sm text-gray-500">
        OWLBEAR: Orchestrated Workflow Logic with Bespoke Experts for Agentic Routines
    </footer>
    
    <!-- Scripts -->
    <script>
        // Configuration
        const API_BASE_URL = window.location.origin + '/api';
        const WS_BASE_URL = window.location.origin.replace('http', 'ws') + '/ws';
        
        // DOM elements
        const traceLogEl = document.getElementById('traceLog');
        const clearTraceBtnEl = document.getElementById('clearTraceBtn');
        const workflowSelectEl = document.getElementById('workflowSelect');
        const stringsContainerEl = document.getElementById('stringsContainer');
        const stringsSelectEl = document.getElementById('stringsSelect');
        const parametersContainerEl = document.getElementById('parametersContainer');
        const parametersFieldsEl = document.getElementById('parametersFields');
        const executeBtnEl = document.getElementById('executeBtn');
        const cancelBtnEl = document.getElementById('cancelBtn');
        const visualizationEl = document.getElementById('visualization');
        
        // State
        let currentWorkflow = null;
        let currentExecution = null;
        let websocket = null;
        let experts = [];
        let stringsFiles = [];
        let compatibleStringsFiles = [];
        
        // Initialize the application
        async function init() {
            await Promise.all([
                loadWorkflows(),
                loadExperts(),
                loadStringsFiles()
            ]);
            
            // Event listeners
            clearTraceBtnEl.addEventListener('click', clearTraceLog);
            workflowSelectEl.addEventListener('change', handleWorkflowChange);
            stringsSelectEl.addEventListener('change', handleStringsChange);
            executeBtnEl.addEventListener('click', executeWorkflow);
            cancelBtnEl.addEventListener('click', cancelWorkflow);
        }
        
        // Load available workflows from the API
        async function loadWorkflows() {
            try {
                const response = await fetch(`${API_BASE_URL}/workflows`);
                if (!response.ok) {
                    throw new Error(`Failed to load workflows: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Clear existing options
                workflowSelectEl.innerHTML = '<option value="">-- Select a workflow --</option>';
                
                // Add workflow options
                data.workflows.forEach(workflow => {
                    const option = document.createElement('option');
                    option.value = workflow.id;
                    option.textContent = workflow.name;
                    option.dataset.compatibleStrings = JSON.stringify(workflow.compatible_strings || []);
                    workflowSelectEl.appendChild(option);
                });
                
                // Enable workflow selection
                workflowSelectEl.disabled = false;
            } catch (error) {
                console.error('Error loading workflows:', error);
                addTraceLog(`Error loading workflows: ${error.message}`, 'error');
            }
        }
        
        // Load available experts from the API
        async function loadExperts() {
            try {
                const response = await fetch(`${API_BASE_URL}/experts`);
                if (!response.ok) {
                    throw new Error(`Failed to load experts: ${response.statusText}`);
                }
                
                const data = await response.json();
                experts = data.experts;
            } catch (error) {
                console.error('Error loading experts:', error);
            }
        }
        
        // Load available strings files from the API
        async function loadStringsFiles() {
            try {
                const response = await fetch(`${API_BASE_URL}/strings`);
                if (!response.ok) {
                    throw new Error(`Failed to load strings files: ${response.statusText}`);
                }
                
                const data = await response.json();
                stringsFiles = data.strings_files;
                
                // We'll populate the select element when a workflow is selected
            } catch (error) {
                console.error('Error loading strings files:', error);
                addTraceLog(`Error loading strings files: ${error.message}`, 'error');
            }
        }
        
        // Handle workflow selection change
        async function handleWorkflowChange() {
            const workflowId = workflowSelectEl.value;
            console.log(`Workflow selection changed to: ${workflowId}`);
            
            // Reset parameters and disable execution button
            parametersContainerEl.classList.add('hidden');
            parametersFieldsEl.innerHTML = '';
            executeBtnEl.disabled = true;
            
            // Reset strings selection
            stringsContainerEl.classList.add('hidden');
            stringsSelectEl.innerHTML = '<option value="">-- Use strings from workflow --</option>';
            
            if (!workflowId) {
                currentWorkflow = null;
                resetVisualization();
                return;
            }
            
            try {
                // Fetch workflow details
                const response = await fetch(`${API_BASE_URL}/workflows/${workflowId}`);
                if (!response.ok) {
                    throw new Error(`Failed to load workflow details: ${response.statusText}`);
                }
                
                const workflow = await response.json();
                currentWorkflow = workflow;
                
                // Log workflow experts for debugging
                console.log("Workflow Experts:");
                workflow.experts.forEach((expert, index) => {
                    console.log(`  ${index+1}. ID: '${expert.id}', Name: '${expert.name}', Icon: '${expert.icon}'`);
                });
                
                // Update strings file selection
                updateStringsSelection(workflowId);
                
                // Generate parameter fields
                if (workflow.parameters && workflow.parameters.length > 0) {
                    // Show parameters container
                    parametersContainerEl.classList.remove('hidden');
                    
                    // Create fields for each parameter
                    workflow.parameters.forEach(param => {
                        const fieldId = `param-${param.name}`;
                        const fieldDiv = document.createElement('div');
                        
                        const label = document.createElement('label');
                        label.setAttribute('for', fieldId);
                        label.textContent = param.description || param.name;
                        if (param.required) {
                            const required = document.createElement('span');
                            required.textContent = ' *';
                            required.className = 'text-red-500';
                            label.appendChild(required);
                        }
                        label.className = 'block mb-1';
                        
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.id = fieldId;
                        input.name = param.name;
                        input.className = 'w-full bg-gray-800 text-white p-2 rounded border border-gray-700';
                        input.setAttribute('data-required', param.required ? 'true' : 'false');
                        
                        if (param.default_value !== null && param.default_value !== undefined) {
                            input.value = param.default_value;
                        }
                        
                        fieldDiv.appendChild(label);
                        fieldDiv.appendChild(input);
                        parametersFieldsEl.appendChild(fieldDiv);
                    });
                }
                
                // Enable execution button
                executeBtnEl.disabled = false;
                
                console.log("Calling updateVisualization with workflow object");
                // Update visualization
                updateVisualization(workflow);
            } catch (error) {
                console.error('Error loading workflow details:', error);
                addTraceLog(`Error loading workflow details: ${error.message}`, 'error');
            }
        }
        
        // Update strings file selection based on workflow compatibility
        function updateStringsSelection(workflowId) {
            // Get compatible strings files from selected workflow
            const selectedOption = workflowSelectEl.querySelector(`option[value="${workflowId}"]`);
            const compatibleStrings = JSON.parse(selectedOption.dataset.compatibleStrings || '[]');
            
            // Clear existing options
            stringsSelectEl.innerHTML = '<option value="">-- Use strings from workflow --</option>';
            
            // Filter strings files to compatible ones
            const filteredStringsFiles = stringsFiles.filter(file => 
                file.id === "" || compatibleStrings.includes(file.id)
            );
            
            // If there are additional strings files beyond the empty option, show the selection
            if (filteredStringsFiles.length > 1) {
                stringsContainerEl.classList.remove('hidden');
                
                // Add strings file options
                filteredStringsFiles.forEach(file => {
                    if (file.id !== "") { // Skip the empty option, we've already added it
                        const option = document.createElement('option');
                        option.value = file.id;
                        option.textContent = file.name;
                        option.title = file.description;
                        stringsSelectEl.appendChild(option);
                    }
                });
            } else {
                stringsContainerEl.classList.add('hidden');
            }
        }
        
        // Handle strings file selection change
        function handleStringsChange() {
            // If needed, we could update parameter fields based on variables in the strings file
            // For now, we just log the selection
            const stringsId = stringsSelectEl.value;
            console.log(`Selected strings file: ${stringsId}`);
        }
        
        // Execute the selected workflow
        async function executeWorkflow() {
            if (!currentWorkflow) {
                return;
            }
            
            // Validate required parameters
            const missingParams = [];
            const parameters = {};
            
            // Collect parameters from form
            parametersFieldsEl.querySelectorAll('input').forEach(input => {
                const name = input.name;
                const value = input.value.trim();
                const required = input.getAttribute('data-required') === 'true';
                
                // Check if required field is empty
                if (required && !value) {
                    missingParams.push(name);
                }
                
                // Add to parameters object
                parameters[name] = value;
            });
            
            // If missing required parameters, show error
            if (missingParams.length > 0) {
                const message = `Missing required parameters: ${missingParams.join(', ')}`;
                addTraceLog(message, 'error');
                return;
            }
            
            // Add strings file selection to request if one is selected
            const stringsFileId = stringsSelectEl.value;
            const requestData = {
                parameters: parameters
            };
            
            // Only include strings_file if it's specified
            if (stringsFileId) {
                requestData.strings_file = stringsFileId;
            }
            
            try {
                // Disable execute button and show cancel button
                executeBtnEl.disabled = true;
                cancelBtnEl.classList.remove('hidden');
                
                // Execute the workflow
                const response = await fetch(`${API_BASE_URL}/workflows/${currentWorkflow.id}/execute`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to execute workflow: ${response.statusText}`);
                }
                
                const data = await response.json();
                currentExecution = data.execution_id;
                
                // Clear trace log
                clearTraceLog();
                
                // Add initial log message
                addTraceLog(`Starting execution of workflow: ${currentWorkflow.name}`, 'info');
                
                // Connect to WebSocket for real-time updates
                connectWebSocket(data.execution_id);
            } catch (error) {
                console.error('Error executing workflow:', error);
                addTraceLog(`Error executing workflow: ${error.message}`, 'error');
                
                // Re-enable execute button and hide cancel button
                executeBtnEl.disabled = false;
                cancelBtnEl.classList.add('hidden');
            }
        }
        
        // Cancel the current workflow execution
        async function cancelWorkflow() {
            if (!currentExecution || !currentWorkflow) {
                return;
            }
            
            try {
                // Send cancel request
                const response = await fetch(`${API_BASE_URL}/workflows/${currentWorkflow.id}/cancel?execution_id=${currentExecution}`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to cancel workflow: ${response.statusText}`);
                }
                
                addTraceLog('Workflow execution cancelled by user', 'warning');
                
                // Reset execution state
                resetExecutionState();
            } catch (error) {
                console.error('Error cancelling workflow:', error);
                addTraceLog(`Error cancelling workflow: ${error.message}`, 'error');
            }
        }
        
        // Connect to WebSocket for real-time execution updates
        function connectWebSocket(executionId) {
            // Close existing connection if any
            if (websocket) {
                websocket.close();
            }
            
            // Create new WebSocket connection
            websocket = new WebSocket(`${WS_BASE_URL}/execution/${executionId}`);
            
            // WebSocket event handlers
            websocket.onopen = () => {
                console.log('WebSocket connection established');
                addTraceLog('Connected to execution stream', 'info');
            };
            
            websocket.onmessage = (event) => {
                try {
                    console.log("WebSocket message received:", event.data);
                    const message = JSON.parse(event.data);
                    console.log("Parsed message:", message);
                    handleWebSocketMessage(message);
                } catch (error) {
                    console.error('Error handling WebSocket message:', error);
                    console.error('Message data:', event.data);
                }
            };
            
            websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                addTraceLog('WebSocket connection error', 'error');
            };
            
            websocket.onclose = () => {
                console.log('WebSocket connection closed');
                addTraceLog('Disconnected from execution stream', 'info');
            };
        }
        
        // Handle WebSocket messages
        function handleWebSocketMessage(message) {
            console.log(`Handling WebSocket message of type: ${message.type}`);
            
            switch (message.type) {
                case 'log':
                    addTraceLog(message.data.message);
                    break;
                    
                case 'step_update':
                    console.log("Step update received:", message.data);
                    handleStepUpdate(message.data);
                    break;
                    
                case 'tool_call':
                    handleToolCall(message.data);
                    break;
                    
                case 'execution_status':
                    handleExecutionStatus(message.data);
                    break;
                    
                case 'error':
                    addTraceLog(message.data.message, 'error');
                    break;
                    
                case 'health_check':
                    // Ignore health check messages
                    console.log("Health check received");
                    break;
                    
                default:
                    console.log('Unknown message type:', message.type, message);
            }
        }
        
        // Handle step update messages
        function handleStepUpdate(data) {
            const { step_index, action_type, expert_id, status, description } = data;
            
            console.log(`Processing step update - step: ${step_index+1}, expert: ${expert_id}, action: ${action_type}, status: ${status}, description: ${description || '(none)'}`);
            
            // Log the description for debugging
            console.log(`Step ${step_index + 1} description: ${description || action_type}`);
            
            // Add to trace log
            addTraceLog(`Step ${step_index + 1}: ${action_type} with expert ${expert_id} - ${status}`, status === 'completed' ? 'success' : 'info');
            
            try {
                // Update expert status in visualization
                console.log(`Updating expert status for: ${expert_id} to ${status}`);
                updateExpertStatus(expert_id, status);
                
                // Update action box with description or action type
                if (status === 'running') {
                    console.log(`Updating action box with description: '${description || action_type}'`);
                    updateActionBox(description || action_type);
                    
                    // Reset tools box for new step
                    resetToolsBox();
                } else if (status === 'completed') {
                    // NOTE: REMOVED, NOT NEEDED RIGHT NOW, MIGHT RECONSIDER IN FUTURE
                    // // When a step completes, clear the action box after a short delay
                    // console.log(`Updating action box to NO ACTION`);
                    // setTimeout(() => {
                    //     try {
                    //         const actionContent = document.getElementById('action-content');
                    //         if (actionContent) {
                    //             actionContent.textContent = 'No action in progress';
                    //             const actionBox = document.getElementById('action-box');
                    //             if (actionBox) {
                    //                 actionBox.classList.remove('pulse');
                    //             }
                    //         }
                    //     } catch (error) {
                    //         console.error('Error clearing action box:', error);
                    //     }
                    // }, 2000); // 2 second delay
                }
                console.log(`Successfully processed step update for step ${step_index+1}`);
            } catch (error) {
                console.error(`Error handling step update:`, error);
                console.error(`Step data:`, data);
            }
        }
        
        // Update the action box with current action information
        function updateActionBox(actionText) {
            console.log("Updating action box with text:", actionText);
            
            // First find the action-content element
            const actionContent = document.getElementById('action-content');
            
            // If action-content not found, try to find the action box
            if (!actionContent) {
                console.warn("Could not find action-content element, searching for action box");
                const actionBox = document.getElementById('action-box');
                
                // If action box found, try to find content inside it
                if (actionBox) {
                    const contentEl = actionBox.querySelector('.action-content');
                    if (contentEl) {
                        contentEl.textContent = actionText;
                        console.log("Found action-content via selector and updated text");
                        
                        // Add pulse animation
                        actionBox.classList.remove('pulse');
                        void actionBox.offsetWidth; // Force reflow to restart animation
                        actionBox.classList.add('pulse');
                        return;
                    }
                }
                
                // If still not found, search for all content in the visualization
                console.warn("Action box components not found, checking visualization container");
                const vizContainer = document.querySelector('.viz-container');
                if (vizContainer) {
                    // Try to find the action container
                    const actionContainer = vizContainer.querySelector('.action-container');
                    if (actionContainer) {
                        // Try to rebuild the action box
                        console.log("Rebuilding action box");
                        actionContainer.innerHTML = '';
                        
                        // Create new action box
                        const newActionBox = document.createElement('div');
                        newActionBox.className = 'action-box pulse';
                        newActionBox.id = 'action-box';
                        
                        // Add action title
                        const actionTitle = document.createElement('div');
                        actionTitle.className = 'action-title';
                        actionTitle.textContent = 'ACTION';
                        newActionBox.appendChild(actionTitle);
                        
                        // Add action content
                        const newActionContent = document.createElement('div');
                        newActionContent.className = 'action-content';
                        newActionContent.textContent = actionText;
                        newActionContent.id = 'action-content';
                        newActionBox.appendChild(newActionContent);
                        
                        // Add to container
                        actionContainer.appendChild(newActionBox);
                        console.log("Action box rebuilt successfully");
                        return;
                    }
                }
                
                console.error("Could not find or rebuild action box components");
                return;
            }
            
            // If we found action-content, update it
            actionContent.textContent = actionText;
            
            // Highlight the box to draw attention
            const actionBox = document.getElementById('action-box');
            if (actionBox) {
                // Remove previous animation class if any
                actionBox.classList.remove('pulse');
                
                // Force reflow to restart animation
                void actionBox.offsetWidth;
                
                // Add pulse effect
                actionBox.classList.add('pulse');
            }
            
            console.log("Action box updated successfully");
        }
        
        // Handle tool call messages
        function handleToolCall(data) {
            const { expert_id, tool_name, parameters, result } = data;
            
            // Add to trace log
            addTraceLog(`Expert ${expert_id} called tool: ${tool_name}`, 'info');
            
            // If parameters provided, log them
            if (parameters && Object.keys(parameters).length > 0) {
                addTraceLog(`Tool parameters: ${JSON.stringify(parameters)}`, 'debug');
            }
            
            // If result provided, log it
            if (result) {
                addTraceLog(`Tool result: ${result}`, 'debug');
            }
            
            // Update tools visualization
            addToolToVisualization(tool_name);
        }
        
        // Add a tool to the tools visualization
        function addToolToVisualization(toolName) {
            // Find tools content element
            const toolsContent = document.getElementById('tools-content');
            if (!toolsContent) {
                console.error("Could not find tools-content element");
                return;
            }
            
            // Clear "No tools used yet" message if present
            if (toolsContent.textContent === 'No tools used yet') {
                toolsContent.innerHTML = '';
            }
            
            // Create tool item element
            const toolItem = document.createElement('div');
            toolItem.className = 'tool-item';
            
            // Add tool icon
            const toolIcon = document.createElement('i');
            toolIcon.setAttribute('data-feather', 'tool');
            toolIcon.className = 'w-3 h-3';
            toolItem.appendChild(toolIcon);
            
            // Add tool name
            const toolText = document.createTextNode(toolName);
            toolItem.appendChild(toolText);
            
            // Add tool item to tools content
            toolsContent.appendChild(toolItem);
            
            // Initialize Feather Icons for the new icon
            feather.replace();
            
            console.log(`Added tool '${toolName}' to visualization`);
        }
        
        // Reset the tools box
        function resetToolsBox() {
            console.log("Resetting tools box");
            
            // Find tools content element
            const toolsContent = document.getElementById('tools-content');
            if (toolsContent) {
                toolsContent.innerHTML = '';
                toolsContent.textContent = 'No tools used yet';
                console.log("Tools box reset successful");
            } else {
                console.error("Could not find tools-content element");
            }
        }
        
        // Handle execution status messages
        function handleExecutionStatus(data) {
            const { status, error } = data;
            
            // Add to trace log
            addTraceLog(`Execution status: ${status}`, status === 'completed' ? 'success' : status === 'failed' ? 'error' : 'info');
            
            // If error provided, log it
            if (error) {
                addTraceLog(`Error: ${error}`, 'error');
            }
            
            // If execution completed or failed, reset execution state
            if (['completed', 'failed', 'cancelled'].includes(status)) {
                resetExecutionState();
            }
        }
        
        // Add a message to the trace log
        function addTraceLog(message, level = 'info') {
            // Create log element
            const logEl = document.createElement('div');
            
            // Set class based on log level
            logEl.className = `log-${level} mb-1`;
            
            // Add timestamp
            const timestamp = new Date().toLocaleTimeString();
            const timestampEl = document.createElement('span');
            timestampEl.className = 'text-gray-500';
            timestampEl.textContent = `[${timestamp}] `;
            
            // Format message based on log level
            const messageEl = document.createElement('span');
            switch (level) {
                case 'error':
                    messageEl.className = 'ansi-red';
                    break;
                case 'warning':
                    messageEl.className = 'ansi-yellow';
                    break;
                case 'success':
                    messageEl.className = 'ansi-green';
                    break;
                case 'debug':
                    messageEl.className = 'ansi-cyan';
                    break;
                case 'info':
                default:
                    messageEl.className = 'ansi-white';
                    break;
            }
            messageEl.textContent = message;
            
            // Assemble log entry
            logEl.appendChild(timestampEl);
            logEl.appendChild(messageEl);
            
            // Add to trace log
            traceLogEl.appendChild(logEl);
            
            // Scroll to bottom
            traceLogEl.scrollTop = traceLogEl.scrollHeight;
        }
        
        // Clear the trace log
        function clearTraceLog() {
            traceLogEl.innerHTML = '';
        }
        
        // Reset execution state
        function resetExecutionState() {
            // Close WebSocket connection
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            
            // Reset current execution
            currentExecution = null;
            
            // Re-enable execute button and hide cancel button
            executeBtnEl.disabled = false;
            cancelBtnEl.classList.add('hidden');
            
            // Reset expert statuses in visualization
            resetExpertStatuses();
            
            // Reset action box
            const actionContent = document.getElementById('action-content');
            if (actionContent) {
                actionContent.textContent = 'No action in progress';
                
                // Remove any animation
                const actionBox = document.getElementById('action-box');
                if (actionBox) {
                    actionBox.classList.remove('pulse');
                }
            }
            
            // Reset tools box
            resetToolsBox();
        }
        
        // Update the visualization with workflow information
        function updateVisualization(workflow) {
            console.log("updateVisualization called with workflow:", workflow);
            
            // Clear visualization
            visualizationEl.innerHTML = '';
            
            // If no workflow selected, show default message
            if (!workflow || !workflow.experts || workflow.experts.length === 0) {
                visualizationEl.innerHTML = '<div class="text-gray-500 italic">Select a workflow to visualize the experts and their interactions.</div>';
                return;
            }
            
            console.log(`Visualizing workflow with ${workflow.experts.length} experts`);
            
            // Create the visualization container with flex column layout
            const vizContainer = document.createElement('div');
            vizContainer.className = 'viz-container';
            
            // Create experts container
            const expertsContainer = document.createElement('div');
            expertsContainer.className = 'experts-container';
            
            // Create expert elements
            workflow.experts.forEach(expert => {
                const expertEl = createExpertElement(expert);
                expertsContainer.appendChild(expertEl);
            });
            
            // Create action container
            const actionContainer = document.createElement('div');
            actionContainer.className = 'action-container';
            
            // Create action box
            const actionBox = document.createElement('div');
            actionBox.className = 'action-box';
            actionBox.id = 'action-box';
            
            // Add action title
            const actionTitle = document.createElement('div');
            actionTitle.className = 'action-title';
            actionTitle.textContent = 'ACTION';
            actionBox.appendChild(actionTitle);
            
            // Add action content (initially empty)
            const actionContent = document.createElement('div');
            actionContent.className = 'action-content';
            actionContent.textContent = 'No action in progress';
            actionContent.id = 'action-content';
            actionBox.appendChild(actionContent);
            
            // Add action box to container
            actionContainer.appendChild(actionBox);
            
            // Create tools container
            const toolsContainer = document.createElement('div');
            toolsContainer.className = 'tools-container';
            
            // Create tools box
            const toolsBox = document.createElement('div');
            toolsBox.className = 'tools-box';
            toolsBox.id = 'tools-box';
            
            // Add tools title with icon
            const toolsTitle = document.createElement('div');
            toolsTitle.className = 'tools-title';
            
            // Add tool icon
            const toolIcon = document.createElement('i');
            toolIcon.setAttribute('data-feather', 'tool');
            toolIcon.className = 'w-4 h-4';
            toolsTitle.appendChild(toolIcon);
            
            // Add title text
            const titleText = document.createTextNode('TOOLS');
            toolsTitle.appendChild(titleText);
            
            toolsBox.appendChild(toolsTitle);
            
            // Add tools content (initially empty)
            const toolsContent = document.createElement('div');
            toolsContent.className = 'tools-content';
            toolsContent.textContent = 'No tools used yet';
            toolsContent.id = 'tools-content';
            toolsBox.appendChild(toolsContent);
            
            // Add tools box to container
            toolsContainer.appendChild(toolsBox);
            
            // Assemble the visualization
            vizContainer.appendChild(expertsContainer);
            vizContainer.appendChild(actionContainer);
            vizContainer.appendChild(toolsContainer);
            visualizationEl.appendChild(vizContainer);
            
            // Log visualization elements for debugging
            console.log("Visualization elements created:");
            console.log("Container:", vizContainer);
            console.log("Experts container:", expertsContainer);
            console.log("Action box:", actionBox);
            
            // Initialize Feather Icons
            feather.replace();
            
            console.log("Visualization updated successfully");
        }
        
        // Create an expert element for visualization
        function createExpertElement(expert) {
            console.log(`Creating expert element for: ${expert.id}`);
            
            // Normalize expert ID for consistency
            // Keep original expert.id for data purposes, but normalize for DOM element IDs
            const normalizedId = expert.id.toLowerCase();
            
            const expertEl = document.createElement('div');
            expertEl.className = 'expert-node bg-gray-800 rounded-lg p-4 flex flex-col items-center justify-center w-40 h-40 text-center';
            expertEl.id = `expert-${normalizedId}`;
            
            // Store original ID as a data attribute for reference
            expertEl.setAttribute('data-original-id', expert.id);
            
            // Create icon container
            const iconEl = document.createElement('div');
            iconEl.className = 'expert-icon text-gray-400 w-16 h-16 flex items-center justify-center mb-2';
            
            // Create SVG icon using Feather Icons
            const iconSvg = document.createElement('i');
            console.log(`Expert icon for ${expert.name}: ${expert.icon || 'user'}`);
            iconSvg.setAttribute('data-feather', expert.icon || 'user');
            iconSvg.className = 'w-8 h-8'; // Set size
            iconEl.appendChild(iconSvg);
            
            // Create name (keep original case)
            const nameEl = document.createElement('div');
            nameEl.className = 'expert-name font-bold mb-1';
            nameEl.textContent = expert.name;
            
            // Create status indicator (initially hidden)
            const statusEl = document.createElement('div');
            statusEl.className = 'expert-status mt-2 hidden';
            statusEl.id = `expert-status-${normalizedId}`;
            
            // Assemble expert element
            expertEl.appendChild(iconEl);
            expertEl.appendChild(nameEl);
            expertEl.appendChild(statusEl);
            
            console.log(`Created expert element with ID: expert-${normalizedId} (original ID: ${expert.id})`);
            
            return expertEl;
        }
        
        // Update expert status in visualization
        function updateExpertStatus(expertId, status) {
            if (!expertId) {
                console.error("Invalid expert ID: empty or null");
                return;
            }
            
            console.log(`updateExpertStatus called with expertId='${expertId}', status='${status}'`);
            
            // Normalize expert ID (make it case-insensitive)
            // Try both original case and lowercase
            const normalizedExpertId = typeof expertId === 'string' ? expertId.toLowerCase() : String(expertId).toLowerCase();
            
            // Try finding the elements directly by ID
            let statusEl = document.getElementById(`expert-status-${expertId}`);
            let expertEl = document.getElementById(`expert-${expertId}`);
            
            // If not found, try lowercase
            if (!statusEl || !expertEl) {
                statusEl = document.getElementById(`expert-status-${normalizedExpertId}`);
                expertEl = document.getElementById(`expert-${normalizedExpertId}`);
            }
            
            // If still not found, try to find the expert by data attribute
            if (!expertEl) {
                console.log("Looking for expert by data attribute");
                const allExperts = document.querySelectorAll('[data-original-id]');
                allExperts.forEach(el => {
                    const originalId = el.getAttribute('data-original-id');
                    if (originalId && (originalId === expertId || originalId.toLowerCase() === normalizedExpertId)) {
                        console.log(`Found expert by data-original-id: ${originalId}`);
                        expertEl = el;
                        // Also find the corresponding status element
                        const elId = el.id.replace('expert-', '');
                        statusEl = document.getElementById(`expert-status-${elId}`);
                    }
                });
            }
            
            // If still not found, try a more thorough search for expert nodes
            if (!statusEl || !expertEl) {
                console.log("Trying more thorough search of expert nodes");
                const allExpertNodes = document.querySelectorAll('.expert-node');
                console.log(`Found ${allExpertNodes.length} expert nodes`);
                
                console.log("Expert nodes IDs:");
                allExpertNodes.forEach(node => {
                    console.log(`  Expert node ID: ${node.id}`);
                });
                
                // Try to match by ID portion (after "expert-")
                for (const node of allExpertNodes) {
                    const nodeId = node.id.replace('expert-', '');
                    if (nodeId === expertId || nodeId.toLowerCase() === normalizedExpertId) {
                        console.log(`Found expert by node ID match: ${nodeId}`);
                        expertEl = node;
                        statusEl = document.getElementById(`expert-status-${nodeId}`);
                        break;
                    }
                    
                    // Try partial matching on expert ID
                    if (nodeId.includes(normalizedExpertId) || normalizedExpertId.includes(nodeId)) {
                        console.log(`Found expert by partial ID match: ${nodeId} contains or is contained in ${normalizedExpertId}`);
                        expertEl = node;
                        statusEl = document.getElementById(`expert-status-${nodeId}`);
                        break;
                    }
                }
            }
            
            console.log(`Found elements: statusEl=${!!statusEl}, expertEl=${!!expertEl}`);
            
            if (!statusEl || !expertEl) {
                console.error(`Could not find elements for expert: '${expertId}'`);
                console.error(`Normalized ID: '${normalizedExpertId}'`);
                
                // Dump the visualization structure
                console.log("Current visualization structure:");
                const vizContainer = document.querySelector('.viz-container');
                if (vizContainer) {
                    console.log(vizContainer.innerHTML);
                } else {
                    console.log("No visualization container found");
                }
                
                return;
            }
            
            // Find the icon element
            const iconEl = expertEl.querySelector('.expert-icon');
            
            // Show status element
            statusEl.classList.remove('hidden');
            
            // Update status text and class
            switch (status) {
                case 'running':
                    // Update status indicator
                    statusEl.className = 'expert-status mt-2 text-xs bg-blue-500 text-white px-2 py-1 rounded-full pulse';
                    statusEl.textContent = 'Active';
                    
                    // Update expert node to show active state
                    expertEl.classList.add('ring-2', 'ring-blue-500');
                    
                    // Highlight the icon
                    if (iconEl) {
                        iconEl.classList.remove('text-gray-400');
                        iconEl.classList.add('text-blue-400');
                    }
                    break;
                
                case 'completed':
                    // Update status indicator
                    statusEl.className = 'expert-status mt-2 text-xs bg-green-500 text-white px-2 py-1 rounded-full';
                    statusEl.textContent = 'Completed';
                    
                    // Adjust icon color
                    if (iconEl) {
                        iconEl.classList.remove('text-gray-400', 'text-blue-400');
                        iconEl.classList.add('text-green-400');
                    }
                    break;
                    
                case 'failed':
                    // Update status indicator
                    statusEl.className = 'expert-status mt-2 text-xs bg-red-500 text-white px-2 py-1 rounded-full';
                    statusEl.textContent = 'Failed';
                    
                    // Adjust icon color
                    if (iconEl) {
                        iconEl.classList.remove('text-gray-400', 'text-blue-400');
                        iconEl.classList.add('text-red-400');
                    }
                    break;
                    
                case 'waiting':
                default:
                    // Update status indicator
                    statusEl.className = 'expert-status mt-2 text-xs bg-gray-500 text-white px-2 py-1 rounded-full';
                    statusEl.textContent = 'Waiting';
                    
                    // Reset icon color
                    if (iconEl) {
                        iconEl.classList.remove('text-blue-400', 'text-green-400', 'text-red-400');
                        iconEl.classList.add('text-gray-400');
                    }
                    break;
            }
            
            console.log(`Successfully updated expert '${expertId}' status to '${status}'`);
        }
                
        // Reset all expert statuses in visualization
        function resetExpertStatuses() {
            // Hide all status indicators
            document.querySelectorAll('.expert-status').forEach(el => {
                el.classList.add('hidden');
            });
            
            // Remove active state from expert nodes
            document.querySelectorAll('.expert-node').forEach(el => {
                el.classList.remove('ring-2', 'ring-blue-500');
            });
            
            // Reset all icons to gray
            document.querySelectorAll('.expert-icon').forEach(el => {
                el.classList.remove('text-blue-400', 'text-green-400', 'text-red-400');
                el.classList.add('text-gray-400');
            });
        }
        
        // Reset visualization
        function resetVisualization() {
            console.log("Resetting visualization");
            
            // Clear visualization container
            visualizationEl.innerHTML = '<div class="text-gray-500 italic">Select a workflow to visualize the experts and their interactions.</div>';
            
            // No need to reset action box separately since we're clearing the entire visualization
            console.log("Visualization reset complete");
        }
        
        // Initialize the application when the DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
